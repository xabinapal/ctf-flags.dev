---
title: Python 0bf
challenge_type: Rev
writeup_author: "@xabito"
competition: v1t-ctf-2025
summary: |-
  You don't need to deobfuscate the Python, but that's up to you. ;-;
attachments:
  - title: obs.py
    url: /assets/files/v1t-ctf-2025/python-0bf/obs.py
---

## Recon

Although the provided Python script has been obfuscated using an online tool, we can still analyze its structure. By assigning meaningful names to its variables and functions and reorganizing the code, we can better understand how the obfuscation works:

```python
import base64
import zlib

deobfuscate = lambda code : zlib.decompress(base64.b64decode(code[::-1]))
exec(deobfuscate(b'contents'))
```

The script looks quite straightforward, all we need to do is reverse the bytes, decode them using `base64`, and then decompress the result with `zlib`.

## Exploitation

Although there are several ways to approach this, the fastest is likely to use CyberChef with a straightforward recipe that performs all three operations in sequence.

![CyberChef](/assets/files/v1t-ctf-2025/python-0bf/cyberchef.png)

Unless, of course, someone with a particularly devious mindset has created a recursive obfuscator that repeatedly re-applies the same obfuscation process.

## Flag capture (the hard way)

In fact, this is not a problem for us. If you are not familiar with it, CyberChef includes flow control operations. Using these, we can create simple loops and other programming constructs.

All we need to do is repeatedly apply these three operations until we obtain a valid flag. This [recipe](https://gchq.github.io/CyberChef/#recipe=Label('loop')Reverse('Character')From_Base64('A-Za-z0-9%2B/%3D',true,false)Zlib_Inflate(0,0,'Adaptive',false,false)Conditional_Jump('v1t',true,'loop',100)&input=PT1BNFpqUEtEOC8zM24vL1UycXhNUWtaOXdlNjRVK0VRZ2phb0RzWDBBczFjaXN3Tm03cnJEaG8zSjdUcWhvNUM4NkhBM0RCUTBrQXFpSTFRMENMREVEdzJqT25oL1diVzZCRFlLd2d4Mmt3R3lrK3E4RDdTTkpiNUR4aTRkZGxqVkh4citjeUp4dTVZMCtzMllTZmhSSG5ZbXdtcXYrKytpQ1JwQk5DK2dRbitRek0yalhZWFRrSUVDTHNlVkNxcmNtVmlaVGZKclBnZGlGUHJZYTJ3Smw5SlU3TURORXhpL0ZnZ3doSnpYQktOOHhTcXlFc3p6cVJPOTEzTGNQQ3Y0S09TT3FFemtEOHJ2R20weFZaT2JGR1lWUkl6dlRUVFlrSi9lZTNQVTdQOXdFNXFDMUtvOVVRS0ttZVNEdXBTaS81OVVybzlEVHdPWlBEVlFtRXRVblE1dFB5N0YyQVBsdUJJbUFqNFpLbHhiMmFuSkJ3Zk1UMmVsTTJRZ0RPeWsvaS83ODlJUGU1Z1N5QW9KZ2lSM2lYcWtISC96Nm1zNE14RVM0VVc4NVlQYkRDVlRkc2M0WEZDSEpHQ0JadFBQWTlkcTBmbHZBS1BJVVF1cWlRWVo4aTVnMzZLZmgvYkZIM1BBZWdyd3JSeklSeUxOOW5hbTBwdC9HVDhXWWtrbnFiS01ySWJNNDFqUy9WaUR5SnpDQmdPV01ZYjNaYWEwUk0xVlpRVkN6QU5GYUhMOHJwcDJGMnZ2ZFlzWCtkazhEd1hXTGErclM5amYrQm91bDJqZlljQ001RUozU1QvWU9Vd0EveFh0c0VrK3UydHpnL3I3Wm5DQTlkMkRNRCszZVg1SklJSGxXVGIwQUNUQmZMOHBLMDlmZEFTSk14Q1dmTytXMmo3ME9IVll1MGVxMXZWdkUrNWlXR3NTandKeTB6UjdMTnRxUWhhTE55eStjdjJkNTMyajZiL2FyVDFFbGpDZDd5THpvL0xOZm5kYXBaZGtncUVnaXpsc0FyU1B1b3F2T2tUU1VIMnBRWml5bExyUTl0bjlrZEd2S2tvVFZoN1JITHA2YU1yRDQyNFo3NUxleDJZNDNBSkFjUStYVmJ1TTNLellHSHNCb1ovelVidnE4dDRyY0J6QkVVWWNIakYwYXpPZlhRZzc5U2xEZzRDb2VGVzVXb0R6OW5VTVQrcWlpYy9tZlVqZHVnUDE4bDdvaTJiNUVlblc0QllSU3RINHpCS0JEWHhsaXdmRjhJT3Eyck1IZmZhdUo0c3RXVkZJU0l4N202RHdDN1ZaQVl5bnd0czdVWFhHLzNYT1FnN3p6OGRIRjZ1WXM4UjU2S2x2Sk9EK08wczlZWDl2eVNxQitaR29pNVVWRjFCUUNQY2tLOWhaUUk2SG0ycUFuZ2lYUForZ2xjYzh3SEtxSXVaR3NJay9JVTROUHVLTHd0WFBDSzZWQVVDU1dkM3RRNThXVC94eXVyUnFjaWI5MndubC9ObEc2V2h2bFhyNFBuRlVlcC9OdFZNSUJZSGdZakJzK2o2YnhKOFBWQkJkSlVkSzFVYml2d3REdTUrb3p0bW12NnhnTHlOY0NVd1FHZUkrMllsTzNRMVMvL1hJNkNiQlloUWpHNzFxTklDcFpnT1M1VDRackJzeVFvUitsREJ6Tk5ITWlBUjNGKyt2LzdaVnlGb2t6ZWNXYStIN3M1VzR1bUczUUt0VG9OTk45eEpPemNESTFpQytjdDNhcVZjd0k3Z1VsTnRscldhUzhrdWpLTmZZeGV1czJCdnZ6UEdqZ1VhbkJGam1keCs4eWtmdWJxMFoyZXNrTkVsZ1NERlI1Mk5pK3BCcGF0Rm5aUGdpbU9TSmp6TnJvQVd2OFZtMjQrazVBb0xkOG01MWdONnhkN2dLeTZwaktxRmNSK04zNEtzT1Q3WmtFQVZUT3V6OFdHMmt3dVc1TTNhTGo4WkxoSTdCMHp4Zmh4L0RXV1ZHZ1dqVmJiZmpramtGaXQxMllwYzAvZGdHa3Q3dUtzZCtxVTBUV0NQek1XVXdVclVBNmZpcVMzSkFrZHFRT1lGcDJzaVpEbHhEeVhvMEU1SEFCOFVWWGtiYzQ5dEUvcHFpWXRuRjVwditlVGlSWkJrQnBNTFRMOTNMM2FMbC9iMWJIOE9NYVhJN0ZwMnhadlZWcFpINkhGc29WaTMzcU9oaS9oMS9MWkJPR1ptQVZGNkJyLzl2bTFWdW1hbnZQNzdCUWswMSt2bjBlRncwRjF3RGlId1RuWUFpUHFGdUdYSlZmN3hub2pySWwrRGduRmFiY051emdERldnY096ZVBFcE1FbkY0dmVUcnZIbWdJSi9vVUhLY0tnUlJZNHJBdnNPYTJoU041djVleE9pdWVoVDY3elI5TTBzcjNxeEU4NUcya1huZ2FnM0hQSVZYc1hURjMwNFQ5eVVqNzdlTEdDbmd3dlB3V1hXNng5MGRBSXdhell5M0cxU2xXUzFQQXFyL2xlazdnLzJvbTZzMktmQVJOL202UTN2bFZhbUY5bXRUWitvSHAySUJRdUNDRTJvUkk1K2pnOWdEbnFpYkliREFXRmk5dlB4cFl6dnFEZnRTaC9OUjAraGhaaFJQRUJpN2Nxb3NuSXNsZTRrNFcvVUpySFlPQ1hLTytuOExKQ2hubFI4OTUwZ1h3QlZuTDZERXQwNDZRUWwrbnM4Y0c0UkJZQ21zdVJHa0crczhPZlVkSUJTNE4xM2hNY0drVUtzQXRsT2JEVGN0SVl1Unl6SDRZY1ppZTF5bUtqanpreUpFekEwUTBvdElYRXJhTktsTUYxYTc1K2I0V2tBanlWSVJWcDBnNlJDaCtBalpxMzZBK0VRWE16YmNGRStKOGI3eFQ5VzRhb2tHVkVqT0xPU3ZDR3pUYnNUbGJrOXQ1bUVKKzVPTU41diszNVpoV2FnQmFibVlmRXRaL21iUGpaRkY4UjZaRVd6ZkF3K2JJRnlkdkhocFhMZEkvRHpxQ1B4T3d5VTg2c25ZMW84VVdYVWoxK0xTTEd1V0FJb1I0SUY3OGE2dU5OT0xHb1JSUFcwZzRVbnFqZ3V3UkxCWW9vZUhpUUJnbUt2cURBVjlZZkYzUUhMS2ppOUJkOVRiNCt1Slh1eFhsNUE4SHI4NGx3dndrcVRwY1NweUw1c3V3bFF3cmF0OWZVbW45MXJQSklnQ04vdnFwSE9Lby9TNkFWaDdqdmpvdGNYL2paanpWOTZGRGJwUjlrUEVSYmpsVHBKQlltRzVJQjFSUzdFUU15MHQ0Tlp0OEpFZ05IeEZFOEs1SXYzbEZBeDdCMW1zaElGZUpGR0JmV0oxYWpESXErQzVFQTFzamFhcVdnNVhpQittdFRPeElOQkdrUmxiQUhWeVVtMEI5QU9GcWNGK0VNRnQvclpETzBUQm9FRm1icVJPei85MEYybkpSM0duUXNWWTRJZk11ektsMWlFWHFPUFFZTDhPbHVITno1Nk1YT0crTndzb3lja2g2RkdkeGJ1WmlBbWpZSEZZcFkvdElpQW5YbmFNd3BMbnBjUG9SRDVEYkxZZzM3bUo3aEd3RFprdTh1czgyeXcxbVBzRE85K3hDeE1VNFZkTmxCN1FZa3N5cmoyaEk0c0RDeUZ1a1kxVGdGUzZJWWJ3TG5nZ1BYdzQ2ZmxzTW0rWHBKSWpjVDNVUzRRbzFQZkRnWm03eUpLWWxTTmN2WnA1dUJnTzcvQU56dmpIVDZ6dkNSdFk5M1R3bXlDSlUyWFFWQzhPVDMvYjZIUzFTRkQ0aE1hZUFXRkZyZzIzaDRDSHZ6MjJsaU5ITzllSGNoNXpUcE1OdEI5ZDlhYnZKb29XSk5rQUdlUCtJT2srY3gyUUtzbHlaRGpwbVczTFhvR2RZUGpBaytCKzYwbi9DSDh5QzlsRUxkai9XTkV2V3pBbXRBaVJzVHI2b2dtdEl1QnFaNGR5WVFpZ2NMZ1dsaVBnUUpSZlJhOG56M0plcHU3TFVKUEJoNXlOYnRjNWFNdEJueHJnRHh3NlBjSnBPYzdsVkxWMzhCQ0NVUE1UMUEzeXJwQ0xVS2ZYQ3JPemJ1TnREQU1jZGRIVFN5K0xMSVhqa012Ty9QdDN5WStMWGlseGVCMFpQL1hLaENldFBiNkxQVVNSSmU3UkZxWTFVcUlsYnRka3JkSjRJcDh5bCtseW9QbERNZUhrZTFacmppeWo0UW1zWkRNR05WOFpuYWtDV0ROa3gzWHhZazNrN3FkMkpEYWNvOUhFUHhpRW90WFAra0NYTks5aURBZUZob3ZMdEtwODdPN0xaQUZzUUZrR3h3ZjVsSUJWbXIyRGEzQUxWV2IxWW96T2x3MmF3ZHBSRlB5bkhWN0hRT2M2dVNXaXcyMDAweVlINEdLTktIRmc0UHZjdXZmdlIwa1Irckd5em9EWVRFSk9Ja2VaaXgxYlZzWE1WOVgxWGIyclRXMy9CRWhrUDU3VEZqbXFDZ0pTZlRRSk5YcXZOQSs1cytKaXBuVUlpTC93c2Y3R3VFTmYvczJqWEhxa3d0Rk9kS25wR1VtWWdOY0hTQWRDTWdKVzQyRWozdllGaDZjOG0zSStUYkpIYUdxdi9MV0wyaUZPMFBlaWFFbXBFN2owY0ZVS1NGYlA2M2V4Wm5rWFNFOHdYRVVabjJzc0dRNDdySUkwZ2dUNG5pcEMxSFEvcGducHZwY3U0WWlGSmsvMnpBQm0yd2JBNnVCL1MvMkpWVnJ3S29CY2JrdFg1UUhhQWdidE9tNjlvVFlzRHVIdVRiM0VmMkNvYkdaVEM3NmlaNXNvMkIxaFVNUmJKTVN4OGJHWTVVdlpyb0JsYkFiQ0pFYXVQRVRaYi9QODM3U1U3ZWc0c2VjS0t1TWd2eHEwU2dnQmlsbVJldjVVb3B6dFFzcFhibWlZbG9HNkpyOXhOd3I2MW0xZHNTL1hSd256VCt0SC9uYngwaGZRaHFmdDR0bU9jQmlBTXZkUk5NV0RjcXBCRm9MbXpTbFg1QUk1eEcxRS9SOFRpTVB0Y1kzU0k2WGJ4MVRyQ3c1SzFjYzNZZkI1U21YeVVHVGVQZ3h2d0FFVnhhalZaV0pNRnZRMk01aXdyS0VkZ0NtMTF6bnZ0MUFOYmg0ZS90MlM1bU1wL3BEMU1zbkpsY2NSTWIxQUp6cUFJVkluMXB6ckVtUlYwUTQ2b2IzMUJRVndsaXBkbkdoZGhsM3FHN0ZlVGZtKzZMNXVBUld2ckU1Z3I4UG93YjdWKzFodWlpc3RDMndGbjUweS9KZldLUmYwbUFha2hYMyswTnlFN25mUXRHM0ZMNDN0WXl6S2N4ZitWdWpRVTRwNkFSeHg0K0dhcm1QWmlWd1puS2ZTVXpKam4rK2JWNmh5QWkrZzZkcTJIc04xeStDRWh6RCtkMUdHVUJiY2JSdkVCa21GbURSOFZRS0hsMyt0ZitCWG9icXVQc0pRNVo0ODhDYWhCTERKUWI0b2FCUEswY1JpampDU1FpYWZRWEsvMFRlWnZodkRjUGZidTlGQjRseGg4RFNReS9FOVVDZjFtd01zayt1bHUvVmNrbm1iRXM3ejg0N3EzNUMzaXVyejVhVzNRNDNMMlJxcHZRM1J5Y3U5RTF6MFYyWG9IbVk5VVRiRkltY0RZV3B3MTREWmdoNTBtbHdVc3hnczVHUUd5UmdZOWFQaWNrbDFHdVg3c21UNzVqVWRGZjNpSVg0RHZ5am9zMW5xU0hUUkNwWGFFTlhnbW1BckRsNm9wL05renlzd1dJVHZqU2VoNmdNZlhWUzNqM1FIbDRUNFE0TndHaENGZHdBVW9aTkpOdjVUMmlqdE9QQ205MkxFUlo0UlF3cWM1RDR5WE1pNWJvMFhiRFQvSnFzMVJvaWszeHpFa2ZaekdNamlIZ282MitMRTdRVklPaVVSUlJUVytsOGU1VzE1RDhlNy92cCtkTTJRazBETXEvTzltZmJiNXJGNzlwSFJaZ2dDWHRYQmV6MFZaVFRqUVYrZFVOMDE2VnUrdmxhUGxUNFhRdWdVRnpCdlFEMEJsVWVXOGxSeEF3emxqUmFreFBwbmpKeGQyZkd5V3V2S2FkWmtVZ2ZxV1FKSy9kSU0rT1J0eEh6K3lmUkxPUkZuUkplczZBbWNiajBGaTFzbHI0blA0bkhwMUNCTko3am5CV2xXQXlYZjQzcEdqT1pqN0w1Y3pLWDBuendCSy9Qb3VGaHFXTjZKcHkxeTc4NXZ2blVaQVVTNmhHRE4xcDlFZFp6VmlPTWx5MHJacmY0eUljRGFsZUtpQWFKbCszT1NkQXF1b0lMemQwWUR6QmNjSXNZYmVoNWdCTTFneEp5d3FDYTV4YlM0ZVZaYk5Wb296Tzh3WU40cFZBMVh2RFhhOXQ4bUgrNEVRWXdQaVExSlRsYzE3MExJVTFvZEZSTWhjS2h1aUN3Y25jcU8zY2wyT0FrR1czRnFOd0pGZlEwVVFtNnhyaXIwWm5BQnd0elZuQ1FBRkxnaisyTDJJaUxBUzkzRFdVakRFTThXdUR5YkxJZlhLMWcxY1dSdGRVKyt1a1kwMnFPSllGK1hYWjBCdEZaL2FyRHUwYlEwUjAxTUM2d1gzQ2tBWTFZT1MrYXpPUlFZcFd3M24yMllkeHR0ci9BUDZYQStTMlhhZyszWjZCbkhKcEsxN24rMmhacUR1aVVyNlZGMmFBZkxRY1lsaEpzQW9WcDJsODlxRWpIQWxqMFFsazlvait0WTBYcHlYaEJ1YjRDbjV6bDlKUzdYdGlNTWtEUzN2b1N5blh2YThydUxDNjdPS09PZ2MzU0V4ei9yMUo3cnRzWGpSbnpMclZmVFd6SGtaQXFSaDFUazhSSHIwRW5TVUhuOEZESCtENWVMRFlJVS9wKzV2azhvRnVsbEcwSEpjdnhyRnNBMnFBVTM4RndkZm5oQjI3M3BQMHF6OVQyVTh2M3RqVGo1WU5uMUxYUVhKTDd1TlA1MDN5SEQzaHJvcFpPWVFMaElraFBBNGloTENONGNYeEVYMTlWRzRBU0FsUGRRNWkrL24yLzArOS8vbm4vdk1meWlubVIxVkhWWGI1ZC82clBUTU53NXN6QWgxeVVNZEdLMFpuOURSU2dVeHlXN2xOd0pl) in CyberChef accomplishes this almost instantly.

```
flag = "v1t{d4ng_u_kn0w_pyth0n_d3bugg}"

inp = input("Input the flag: ")

if (inp != flag):
    print("wrong")
else:
    print("correct")
```

There is no need to run the code at all!

```
Flag: v1t{d4ng_u_kn0w_pyth0n_d3bugg}
```

## Flag capture (the easy way)

Alternatively, we can refer to the challenge description, which suggests that deobfuscating the original Python script is unnecessary.

Indeed, this is correct. We can simply execute the script within an interactive Python REPL to retrieve the flag:

```bash
$ python
>>> import obs
Input the flag: no idea
wrong

>>> dir(obs)
['_', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'flag', 'inp']

>>> obs.flag
'v1t{d4ng_u_kn0w_pyth0n_d3bugg}'
```